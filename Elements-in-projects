1. Multiple to do list - create/view/update/delete mutiple to do lists(each list has names and multiple to do items)
2. Todo items - create/view/update/delete mutiple to do items(each list has label, a checked unchecked status and belongs to specific list)

3. Real time updates - any changes to the list changes the real time updates
4. Responsive design - can work on desktop and mobile devices

consists of 2 main structes ->
1.to do list ->
{
"_id" : ObjectId,
"name": String
"items":[
{
  "id" : String,
  "label" : String,
  "checked" : Boolean
}
]}

summary for displaying all the lists in the to-do list ->
{
"_id" : ObjectId,
"name": String
"item_count": Integer
}

Fast API backend will have the following end points :
To do lists ->
1. GET/api/lists : Retrieve all todo lists (summary view)
2. POST /api/lists : Create a new todo list
3. GET /api/lists{list_id} : Retrive a todo list with all items 
4. DELETE /api/lists/{list_id} : Delete a specific todo list

To do items ->
1. POST /api/lists/{list_id}/items : Add a new item to a specific list
2. PATCH /api/lists/{list_id}/Checked_state : Update checked state
3. DELETE /api/lists/{list_id}/items/{item_id}: Delete item from list

| Endpoint                               | Method | Purpose             | Example                        |
| -------------------------------------- | ------ | ------------------- | ------------------------------ |
| `/api/lists`                           | GET    | Get all lists       | `[{"id":1,"name":"Shopping"}]` |
| `/api/lists`                           | POST   | Create a list       | `{"name":"Weekend Tasks"}`     |
| `/api/lists/{list_id}`                 | GET    | Get list with items | `{"id":1,"items":[...]}`       |
| `/api/lists/{list_id}`                 | DELETE | Delete list         | `{"message":"List deleted"}`   |
| `/api/lists/{list_id}/items`           | POST   | Add item            | `{"name":"Buy bread"}`         |
| `/api/lists/{list_id}/Checked_state`   | PATCH  | Update checked      | `{"item_id":2,"checked":true}` |
| `/api/lists/{list_id}/items/{item_id}` | DELETE | Delete item         | `{"message":"Item deleted"}`   |

| Method | Purpose                                  |
| ------ | ---------------------------------------- |
| GET    | Retrieve data from the server.           |
| POST   | Create a new resource on the server.     |
| PUT    | Replace an existing resource completely. |
| PATCH  | Partially update an existing resource.   |
| $push  | Add an element to an array in MongoDB.   |


Starting the file ->
new document - farm-todo 
then make 2 folders -> backend and frontend

cd backend
create 2 files Dockerfile, pyproject.toml
then environment venv 
venv -> pip install "fastapi[all]" "motor[srv]" beanie aiostream

to create a txt file ->
pip freeze > requirements.txt 

GIVE INSTRUCTION TO ->
Dockerfile and pyproject.toml files

then create an folder 'src' in backend
in src -> create 2 files inside
1. server.py 
2. dal.py


dal.py ->
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorCollection
from pymongo import ReturnDocument
from pydantic import BaseModel
from uuid import uuid4

bson.ObjectId → Represents MongoDB’s _id values.
AsyncIOMotorCollection → Asynchronous MongoDB collection from Motor.
ReturnDocument → Used in find_one_and_update to specify whether to return the document before or after update.
BaseModel → Pydantic model for data validation and parsing.
uuid4 → Generates unique IDs for To-Do items.

(this is for the summary all the items in the list 
These models define the shape of your data in Python and provide conversion from MongoDB documents (dicts) to Python objects.
class ListSummary(BaseModel):
  id: str
  name: str
  item_count: int

Converts a MongoDB document (doc) to a ListSummary instance.
Converts _id to a string for easier handling in Python/JSON.
  @staticmethod
  def from_doc(doc) -> "ListSummary":
      return ListSummary(
          id=str(doc["_id"]),
          name=doc["name"],
          item_count=doc["item_count"],
      )

similarly, for todo list ->
this code defines the shape of the pydantic model ->
class ToDoListItem(BaseModel):
  id: str
  label: str
  checked: bool

this code it to convet the database into from mongodb to pydantic model data 
this also creates an instance of the pydantic model ->
  @staticmethod
  def from_doc(item) -> "ToDoListItem":
      return ToDoListItem(
          id=item["_id"],
          label=item["label"],
          checked=item["checked"],
      )

similarly we define the shape of pydantic model ->
class ToDoList(BaseModel):
  id: str
  name: str
  items: list[ToDoListItem]

then we create an intance to convert the mongodb data into pydantic python objects ->
@staticmethod
  def from_doc(doc) -> "ToDoList":
      return ToDoList(
          id=str(doc["_id"]),
          name=doc["name"],
          items=[ToDoListItem.from_doc(item) for item in doc["items"]],
      )

| Model            | Used For        | Contains             | Why separate?            |
| ---------------- | --------------- | -------------------- | ------------------------ |
| **ListSummary**  | List overview   | id, name, item_count | Lightweight, fast for UI |
| **ToDoListItem** | Individual item | id, label, checked   | Modular, reusable        |
| **ToDoList**     | Full list       | id, name, items[]    | Complete representation  |

Data Access Layer (DAL)
The ToDoDAL class is responsible for all MongoDB operations related to To-Do lists.
It abstracts away database logic so the rest of the app can just call these methods.

def __init__(self, todo_collection: AsyncIOMotorCollection):
      self._todo_collection = todo_collection

async : allows Python to run non-blocking code. With async, Python can continue doing other work while waiting — instead of freezing.

return -> Stops the function and returns a single value
yield -> Pauses the function and returns a value, but can continue later

$ (positional operator) -> Targets the matched array element (items.$.checked)

These functions talk to MongoDB, perform CRUD operations, and then convert the 
database documents into Pydantic models for clean, typed use in your application.

| Method                  | Purpose                              | MongoDB Operation                 | What It Does                                 | Returns                   |
| ----------------------- | ------------------------------------ | --------------------------------- | -------------------------------------------- | ------------------------- |
| **`list_todo_lists`**   | List all to-do lists with item count | `find()`                          | Uses projection + `$size`, sorted by name    | `ListSummary` (generator) |
| **`create_todo_list`**  | Create a new to-do list              | `insert_one()`                    | Inserts `{name, items: []}`                  | New list ID (string)      |
| **`get_todo_list`**     | Get one list by ID                   | `find_one()`                      | Fetches and converts to Pydantic             | `ToDoList`                |
| **`delete_todo_list`**  | Delete a list                        | `delete_one()`                    | Removes document by `_id`                    | `True` / `False`          |
| **`create_item`**       | Add an item to a list                | `find_one_and_update()` + `$push` | Pushes new item into `items` array           | Updated `ToDoList`        |
| **`set_checked_state`** | Update item’s checked field          | `find_one_and_update()` + `$set`  | Uses positional `$` to update the right item | Updated `ToDoList`        |
| **`delete_item`**       | Remove an item                       | `find_one_and_update()` + `$pull` | Pulls item with matching `id` from array     | Updated `ToDoList`        |



server.py ->
| **Component / Line**                                  | **Purpose / Action**                                                          |
| ----------------------------------------------------- | ----------------------------------------------------------------------------- |
| `imports`                                             | Load modules for async, FastAPI, MongoDB, Pydantic, and server runtime.       |
| `COLLECTION_NAME`, `MONGODB_URI`, `DEBUG`             | Configure MongoDB collection, connection string, and debug mode.              |
| `@asynccontextmanager lifespan`                       | Startup: connect to MongoDB, check DB, attach DAL; Shutdown: close client.    |
| `app = FastAPI(...)`                                  | Create FastAPI app with lifespan and debug settings.                          |
| `@app.get("/api/lists")`                              | Get all to-do lists.                                                          |
| `@app.post("/api/lists")`                             | Create a new to-do list.                                                      |
| `@app.get("/api/lists/{list_id}")`                    | Get a single to-do list by ID.                                                |
| `@app.delete("/api/lists/{list_id}")`                 | Delete a to-do list.                                                          |
| `@app.post("/api/lists/{list_id}/items/")`            | Add a new item to a list.                                                     |
| `@app.delete("/api/lists/{list_id}/items/{item_id}")` | Delete an item from a list.                                                   |
| `@app.patch("/api/lists/{list_id}/checked_state")`    | Update checked state of an item.                                              |
| `@app.get("/api/dummy")`                              | Return dummy ID and timestamp (test endpoint).                                |
| `main()`                                              | Run Uvicorn server on host `0.0.0.0:3001` with optional reload in debug mode. |


the server.py is connected to dal.py by ->
app -> sderver.py object : app = FastAPI(lifespan=lifespan, debug=DEBUG)
todo_dal -> which is an dal.py object : app.todo_dal = ToDoDAL(todo_lists)

when we say app.todo_dal we connect server.py to dal.py for the shape and instances ?

| Term           | What it is                                      | Role / Connection                                                     |
| -------------- | ----------------------------------------------- | --------------------------------------------------------------------- |
| `app`          | FastAPI application instance (from `server.py`) | Represents the running server and holds shared objects.               |
| `ToDoDAL`      | Class in `dal.py`                               | Encapsulates database operations (CRUD) for to-do lists/items.        |
| `app.todo_dal` | Instance of `ToDoDAL` attached to `app`         | Provides **a way for all routes in `server.py` to call DAL methods**. |

where all this happens is inside the lifespan context manager in server.py ->
@asynccontextmanager
async def lifespan(app: FastAPI):
    client = AsyncIOMotorClient(MONGODB_URI)
    database = client.get_default_database()
    todo_lists = database.get_collection(COLLECTION_NAME)

    # <-- This line defines the DAL instance
    app.todo_dal = ToDoDAL(todo_lists)

    yield
    client.close()


note : | Keyword | What it does                                        | Usage                         | Notes                                                                                   |
| ------- | --------------------------------------------------- | ----------------------------- | --------------------------------------------------------------------------------------- |
| `async` | Declares a coroutine function that can pause/resume | `async def fetch_data(): ...` | Makes the function return a coroutine object                                            |
| `await` | Pauses execution until an async operation completes | `result = await fetch_data()` | Can only be used inside an `async` function; executes the coroutine and gets the result |

| Concept                            | Purpose                                                                    |
| ---------------------------------- | -------------------------------------------------------------------------- |
| `async` / `await`                  | Make the code **non-blocking**; wait for result asynchronously             |
| `ReturnDocument.AFTER` / `.BEFORE` | Decide whether MongoDB returns the **document before or after the update** |


CREATING A MONGODB DATABASE ->
mongodb.com -> sign in -> create a new project

new project(farmstack) -> create -> cluster -> new cluster -> connection to your application (drivers) -> setup done

we connect the cluster to -> username/password from project -> drivers copy the mongodb uri ->
ex : mongodb+srv://vknd6976_db_user:<db_password>@cluster0.ys8eb3i.mongodb.net/?appName=Cluster0

then we go to visual studio code ->
to create a new '.env' file in the farm-todo directory we use ->
touch .env ( in the terminal with path till farm-todo)
IN THE .ENV WE DO ->
MONGODB_URI = 'PASTE THE URI'
MONGODB_URI ='mongodb+srv://vknd6976_db_user:<db_password>@cluster0.ys8eb3i.mongodb.net/?appName=Cluster0'
THEN IN THE PASS WORD ENTER THE PASSWORD , zJM9YaHJkoRXTkRT
BEFORE THE ? WE ENTER THE DATABASE NAME CALLED 'todo'

MONGODB_URI ='mongodb+srv://vknd6976_db_user:zJM9YaHJkoRXTkRT@cluster0.ys8eb3i.mongodb.net/todo?appName=Cluster0'

we create the docker composed file ->
in root directory (farm-todo) -> create 'compose.yaml'

this is the docker compose configuration file ->
the code to run multidocker container applications

explanation ->
Top-level
name: todo-app
services:
  ...
Defines the project name as todo-app.
services lists the containers that Docker Compose will run. In this case: nginx, frontend, and backend.
2️⃣ Service: nginx
nginx:
  image: nginx:1.17
  volumes:
    - ./nginx/nginx.conf:/etc/nginx/conf.d/default.conf
  ports:
    - 8000:80
  depends_on:
    - backend
    - frontend
Explanation:
Uses the official nginx image version 1.17.
Mounts your local ./nginx/nginx.conf file into the container to configure nginx.
Maps container port 80 → host port 8000 (localhost:8000).
depends_on ensures nginx starts after the frontend and backend services.
Essentially, nginx acts as a reverse proxy for your frontend and backend.
3️⃣ Service: frontend
frontend:
  image: "node:22"
  user: "node"
  working_dir: /home/node/app
  environment:
    - NODE_ENV=development
    - WDS_SOCKET_PORT=0
  volumes:
    - ./frontend/:/home/node/app
  expose:
    - "3000"
  ports:
    - "3000:3000"
  command: "npm start"
Explanation:
Uses Node.js version 22 image.
Runs as the node user (not root).
Sets working directory inside container: /home/node/app.
Environment variables:
NODE_ENV=development → enables dev mode
WDS_SOCKET_PORT=0 → configures Webpack Dev Server
Mounts local ./frontend/ folder into container → changes in code are live (hot reload).
Exposes port 3000 internally and maps to host port 3000.
Runs npm start → starts the frontend app (likely React/Vue/Next.js).
4️⃣ Service: backend
backend:
  image: todo-app/backend
  build: ./backend
  volumes:
    - ./backend/:/usr/src/app
  expose:
    - "3001"
  ports:
    - "8001:3001"
  command: "python src/server.py"
  environment:
    - DEBUG=true
  env_file:
    - path: ./.env
      required: true
Explanation:
Custom image todo-app/backend built from ./backend directory.
Mounts local backend code into container → changes are live.
Exposes port 3001 internally and maps to host port 8001.
Runs backend server: python src/server.py.
Environment variable: DEBUG=true.
Loads additional environment variables from .env (required file).

How it all works together
backend → Python API server on port 3001
frontend → Node.js app on port 3000
nginx → listens on host port 8000, proxies traffic to frontend/backend

What is Nginx?
Nginx is a high-performance web server and reverse proxy server.
Originally developed for serving static websites efficiently
Now widely used for load balancing, caching, and reverse proxying

Browser → request → nginx container (port 8000)
Nginx forwards requests to:
frontend service (Node.js app on port 3000)
backend service (Python API on port 3001)
Nginx can also serve static files or handle HTTPS

How traffic flows
Browser → Nginx (localhost:8000)
Nginx receives the request.
Based on its configuration, it decides whether to forward the request to frontend or backend.
Nginx → Frontend (container port 3000)
If it’s a request for the web app (like /), nginx forwards it to the frontend container.
Nginx → Backend (container port 3001)
If it’s an API request (like /api/todos), nginx forwards it to the backend container.

we create a 'ngnix' directory ->
create a file named 'ngnix.conf' ->
code :
server {
    listen 80;
    server_name farm_intro;

    location / {
        proxy_pass http://frontend:3000;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }

    location /api {
        proxy_pass http://backend:3001/api;
    }
}


/ → frontend
/api → backend
proxy_set_header Upgrade $http_upgrade + Connection "upgrade" → needed for WebSocket support (like React/Vue dev server hot reload)
Keeps frontend and backend on separate ports internally, but users access everything via Nginx on port 80 (or 8000 mapped externally)

now setting up the react application ->
farm-todo -> frontend -> 
in terminal : npx create-react-app .
note : we have to give a name to the react , but if you want to create a react app without a name we use "." instead of "my-app"

install more dependencies : npm install axios react-icons

in frontend -> src ->app.js -> 
Fetches all To-Do lists from the API on load.
Shows either the list of all To-Do lists or a single selected list.
Lets you create a new list, delete a list, and select a list to view.
State (selectedItem) controls which view is shown.
Reloads data from the API after any create or delete action.

function handleDeleteToDoList(id) {
  const updateData = async () => {
    await axios.delete(`/api/lists/${id}`);
    reloadData().catch(console.error);
  };
  updateData();
}

explanation ->
handleDeleteToDoList(id) is called when you want to delete a To-Do list.
Inside it, updateData is an async function that:
Sends a DELETE request to the backend API for the list with the given id.
After the deletion, it calls reloadData() to fetch the updated list from the backend so the UI shows the latest data.
updateData() is called immediately to perform the deletion.

axios is a JavaScript library for making HTTP requests 


To run the project ->
terminal :farm-todo % docker-compose up --build








