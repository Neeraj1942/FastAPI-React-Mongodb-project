1. Multiple to do list - create/view/update/delete mutiple to do lists(each list has names and multiple to do items)
2. Todo items - create/view/update/delete mutiple to do items(each list has label, a checked unchecked status and belongs to specific list)

3. Real time updates - any changes to the list changes the real time updates
4. Responsive design - can work on desktop and mobile devices

consists of 2 main structes ->
1.to do list ->
{
"_id" : ObjectId,
"name": String
"items":[
{
  "id" : String,
  "label" : String,
  "checked" : Boolean
}
]}

summary for displaying all the lists in the to-do list ->
{
"_id" : ObjectId,
"name": String
"item_count": Integer
}

Fast API backend will have the following end points :
To do lists ->
1. GET/api/lists : Retrieve all todo lists (summary view)
2. POST /api/lists : Create a new todo list
3. GET /api/lists{list_id} : Retrive a todo list with all items 
4. DELETE /api/lists/{list_id} : Delete a specific todo list

To do items ->
1. POST /api/lists/{list_id}/items : Add a new item to a specific list
2. PATCH /api/lists/{list_id}/Checked_state : Update checked state
3. DELETE /api/lists/{list_id}/items/{item_id}: Delete item from list

| Endpoint                               | Method | Purpose             | Example                        |
| -------------------------------------- | ------ | ------------------- | ------------------------------ |
| `/api/lists`                           | GET    | Get all lists       | `[{"id":1,"name":"Shopping"}]` |
| `/api/lists`                           | POST   | Create a list       | `{"name":"Weekend Tasks"}`     |
| `/api/lists/{list_id}`                 | GET    | Get list with items | `{"id":1,"items":[...]}`       |
| `/api/lists/{list_id}`                 | DELETE | Delete list         | `{"message":"List deleted"}`   |
| `/api/lists/{list_id}/items`           | POST   | Add item            | `{"name":"Buy bread"}`         |
| `/api/lists/{list_id}/Checked_state`   | PATCH  | Update checked      | `{"item_id":2,"checked":true}` |
| `/api/lists/{list_id}/items/{item_id}` | DELETE | Delete item         | `{"message":"Item deleted"}`   |

| Method | Purpose                                  |
| ------ | ---------------------------------------- |
| GET    | Retrieve data from the server.           |
| POST   | Create a new resource on the server.     |
| PUT    | Replace an existing resource completely. |
| PATCH  | Partially update an existing resource.   |
| $push  | Add an element to an array in MongoDB.   |


Starting the file ->
new document - farm-todo 
then make 2 folders -> backend and frontend

cd backend
create 2 files Dockerfile, pyproject.toml
then environment venv 
venv -> pip install "fastapi[all]" "motor[srv]" beanie aiostream

to create a txt file ->
pip freeze > requirements.txt 

GIVE INSTRUCTION TO ->
Dockerfile and pyproject.toml files

then create an folder 'src' in backend
in src -> create 2 files inside
1. server.py 
2. dal.py


dal.py ->
from bson import ObjectId
from motor.motor_asyncio import AsyncIOMotorCollection
from pymongo import ReturnDocument
from pydantic import BaseModel
from uuid import uuid4

bson.ObjectId → Represents MongoDB’s _id values.
AsyncIOMotorCollection → Asynchronous MongoDB collection from Motor.
ReturnDocument → Used in find_one_and_update to specify whether to return the document before or after update.
BaseModel → Pydantic model for data validation and parsing.
uuid4 → Generates unique IDs for To-Do items.

(this is for the summary all the items in the list 
These models define the shape of your data in Python and provide conversion from MongoDB documents (dicts) to Python objects.
class ListSummary(BaseModel):
  id: str
  name: str
  item_count: int

Converts a MongoDB document (doc) to a ListSummary instance.
Converts _id to a string for easier handling in Python/JSON.
  @staticmethod
  def from_doc(doc) -> "ListSummary":
      return ListSummary(
          id=str(doc["_id"]),
          name=doc["name"],
          item_count=doc["item_count"],
      )

similarly, for todo list ->
this code defines the shape of the pydantic model ->
class ToDoListItem(BaseModel):
  id: str
  label: str
  checked: bool

this code it to convet the database into from mongodb to pydantic model data 
this also creates an instance of the pydantic model ->
  @staticmethod
  def from_doc(item) -> "ToDoListItem":
      return ToDoListItem(
          id=item["_id"],
          label=item["label"],
          checked=item["checked"],
      )

similarly we define the shape of pydantic model ->
class ToDoList(BaseModel):
  id: str
  name: str
  items: list[ToDoListItem]

then we create an intance to convert the mongodb data into pydantic python objects ->
@staticmethod
  def from_doc(doc) -> "ToDoList":
      return ToDoList(
          id=str(doc["_id"]),
          name=doc["name"],
          items=[ToDoListItem.from_doc(item) for item in doc["items"]],
      )

| Model            | Used For        | Contains             | Why separate?            |
| ---------------- | --------------- | -------------------- | ------------------------ |
| **ListSummary**  | List overview   | id, name, item_count | Lightweight, fast for UI |
| **ToDoListItem** | Individual item | id, label, checked   | Modular, reusable        |
| **ToDoList**     | Full list       | id, name, items[]    | Complete representation  |

Data Access Layer (DAL)
The ToDoDAL class is responsible for all MongoDB operations related to To-Do lists.
It abstracts away database logic so the rest of the app can just call these methods.

def __init__(self, todo_collection: AsyncIOMotorCollection):
      self._todo_collection = todo_collection

async : allows Python to run non-blocking code. With async, Python can continue doing other work while waiting — instead of freezing.

return -> Stops the function and returns a single value
yield -> Pauses the function and returns a value, but can continue later

$ (positional operator) -> Targets the matched array element (items.$.checked)

These functions talk to MongoDB, perform CRUD operations, and then convert the 
database documents into Pydantic models for clean, typed use in your application.

| Method                  | Purpose                              | MongoDB Operation                 | What It Does                                 | Returns                   |
| ----------------------- | ------------------------------------ | --------------------------------- | -------------------------------------------- | ------------------------- |
| **`list_todo_lists`**   | List all to-do lists with item count | `find()`                          | Uses projection + `$size`, sorted by name    | `ListSummary` (generator) |
| **`create_todo_list`**  | Create a new to-do list              | `insert_one()`                    | Inserts `{name, items: []}`                  | New list ID (string)      |
| **`get_todo_list`**     | Get one list by ID                   | `find_one()`                      | Fetches and converts to Pydantic             | `ToDoList`                |
| **`delete_todo_list`**  | Delete a list                        | `delete_one()`                    | Removes document by `_id`                    | `True` / `False`          |
| **`create_item`**       | Add an item to a list                | `find_one_and_update()` + `$push` | Pushes new item into `items` array           | Updated `ToDoList`        |
| **`set_checked_state`** | Update item’s checked field          | `find_one_and_update()` + `$set`  | Uses positional `$` to update the right item | Updated `ToDoList`        |
| **`delete_item`**       | Remove an item                       | `find_one_and_update()` + `$pull` | Pulls item with matching `id` from array     | Updated `ToDoList`        |



server.py ->
| **Component / Line**                                  | **Purpose / Action**                                                          |
| ----------------------------------------------------- | ----------------------------------------------------------------------------- |
| `imports`                                             | Load modules for async, FastAPI, MongoDB, Pydantic, and server runtime.       |
| `COLLECTION_NAME`, `MONGODB_URI`, `DEBUG`             | Configure MongoDB collection, connection string, and debug mode.              |
| `@asynccontextmanager lifespan`                       | Startup: connect to MongoDB, check DB, attach DAL; Shutdown: close client.    |
| `app = FastAPI(...)`                                  | Create FastAPI app with lifespan and debug settings.                          |
| `@app.get("/api/lists")`                              | Get all to-do lists.                                                          |
| `@app.post("/api/lists")`                             | Create a new to-do list.                                                      |
| `@app.get("/api/lists/{list_id}")`                    | Get a single to-do list by ID.                                                |
| `@app.delete("/api/lists/{list_id}")`                 | Delete a to-do list.                                                          |
| `@app.post("/api/lists/{list_id}/items/")`            | Add a new item to a list.                                                     |
| `@app.delete("/api/lists/{list_id}/items/{item_id}")` | Delete an item from a list.                                                   |
| `@app.patch("/api/lists/{list_id}/checked_state")`    | Update checked state of an item.                                              |
| `@app.get("/api/dummy")`                              | Return dummy ID and timestamp (test endpoint).                                |
| `main()`                                              | Run Uvicorn server on host `0.0.0.0:3001` with optional reload in debug mode. |


the server.py is connected to dal.py by ->
app -> sderver.py object : app = FastAPI(lifespan=lifespan, debug=DEBUG)
todo_dal -> which is an dal.py object : app.todo_dal = ToDoDAL(todo_lists)

when we say app.todo_dal we connect server.py to dal.py for the shape and instances ?

| Term           | What it is                                      | Role / Connection                                                     |
| -------------- | ----------------------------------------------- | --------------------------------------------------------------------- |
| `app`          | FastAPI application instance (from `server.py`) | Represents the running server and holds shared objects.               |
| `ToDoDAL`      | Class in `dal.py`                               | Encapsulates database operations (CRUD) for to-do lists/items.        |
| `app.todo_dal` | Instance of `ToDoDAL` attached to `app`         | Provides **a way for all routes in `server.py` to call DAL methods**. |

where all this happens is inside the lifespan context manager in server.py ->
@asynccontextmanager
async def lifespan(app: FastAPI):
    client = AsyncIOMotorClient(MONGODB_URI)
    database = client.get_default_database()
    todo_lists = database.get_collection(COLLECTION_NAME)

    # <-- This line defines the DAL instance
    app.todo_dal = ToDoDAL(todo_lists)

    yield
    client.close()


note : | Keyword | What it does                                        | Usage                         | Notes                                                                                   |
| ------- | --------------------------------------------------- | ----------------------------- | --------------------------------------------------------------------------------------- |
| `async` | Declares a coroutine function that can pause/resume | `async def fetch_data(): ...` | Makes the function return a coroutine object                                            |
| `await` | Pauses execution until an async operation completes | `result = await fetch_data()` | Can only be used inside an `async` function; executes the coroutine and gets the result |

| Concept                            | Purpose                                                                    |
| ---------------------------------- | -------------------------------------------------------------------------- |
| `async` / `await`                  | Make the code **non-blocking**; wait for result asynchronously             |
| `ReturnDocument.AFTER` / `.BEFORE` | Decide whether MongoDB returns the **document before or after the update** |













